<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Project 1</title>
</head>
<body>

<h1>Project 1: Colorizing the Prokudin-Gorskii photo collection</h1>
<div align="center">
<p>
by lesley330404
</p>
</div>

<!-- Section 1 -->
<h2>Introduction</h2>
<p>
The Prokudin-Gorskii photo collection consists of 3 digitalized glass plate images, each taken in grayscale with a blue, green, and red filter (ordered from top to bottom). To obtain a colorized version of the original image, we can align the images and use the pixel brightness (normalized to [0, 255]) from each image as the value of its respective color channel. This project aims to perform the aligning and compositing process automatically, given any image containing the 3 glass plates in BGR order.
</p>
<div align="center">
<img src="images/intro.png" alt="intro.png">
</div>
<hr>

<!-- Section 2 -->
<h2>NCC & Preprocessing</h2>
<p>
To begin the alignment process, we need a function that can compute a similarity score between 2 images. Motivated by the fact that given <i>a + b = c</i>, <i>ab</i> attains its highest value at <i>a = b = c/2</i>, we can use the normalized cross-correlation
</p>
<div align="center">
<img src="images/equation.png" alt="equation.png" width="25%">
</div>
<p>
for 2 vectors <strong>x</strong> and <strong>y</strong>. After normalizing each image with the L<sup>2</sup> norm, the dot product will ensure that the score will be the highest when the features of both images are the most similar. Since grayscale images are represented by 2d arrays, we can first flatten the 2 images we want to compare, before using them as the input vectors. A caveat of this method is that both images should be the same size. However, we can approximate the crop dimensions for just the blue and red plates and find the best displacements with respect to the green plate. The final step would require us to find the intersection of 3 rectangles, which is illustrated below:
</p>
<div align="center">
<img src="images/proj1.png" alt="proj1.png" width="50%">
</div>
<hr>

<!-- Section 3 -->
<h2>Naive Search</h2>
<p>
To find the best shift, the simplest way is to compute the NCC for every possible shift within the full image. However, not only is this inefficient, but the best shift would also just be (0, 0) for any image, since the crop would just be a copy of the original crop. To solve this issue, we need to limit how much the height can shift when aligning.<br>
<br>
Define <i>W</i> and <i>H</i> to be the width and height of the full image, and asssume, for approximations, that each plate takes up exactly a third of the full image. Considering only the top/blue plate, we can start by setting the upper limit for the top edge to be <i>(0 + H/3) / 2 = H/6</i>, and the bottom edge to be <i>(2H / 3 + H) / 2 = 5H / 6</i>. This means the top edge should be at least shifted down by <i>H/6 - 0 = H/6</i>, and the bottom edge by <i>5H / 6 - H/3 = H/2</i>. Therefore, a good place to start is a displacement of <i>(0, (H/6 + H/2) / 2) = (0, H/3)</i> with a search range of [<i>-H/6</i>, <i>H/6</i>]. For the bottom/red plate, the equivalent displacement is just <i>(0, -H/3)</i> with the same search range. Any shifts that brings the crop outside the original image will be ignored.<br>
<br>
Using a starting crop of {<i>(W/16, H/16), (W - W/16, H/3 - H/16)</i>} for the blue plate and {<i>(W/16, 2H / 3 + H/16), (W - W/16, H - H/16)</i>} for the red plate, where the tuples are the upper left and lower right corner pixels in (<i>x</i>, <i>y</i>) coordinates, we can obtain the following best shifts:
</p>

<div class="two-up" style="display:flex;" role="group" aria-label="Image comparison">

<figure style="flex:1; text-align:center;">
<div class="figure-wrap">
<figcaption>cathedral.jpg</figcaption>
<img class="media" src="images/cathedralNaive.jpg"
alt="cathedralNaive.jpg" loading="lazy" width="50%"/>
</div>
<figcaption>Best shift: (-2, 336), (1, -334)<br>5.070914s</figcaption>
</figure>

<figure style="flex:1; text-align:center;">
<div class="figure-wrap">
<figcaption>monastery.jpg</figcaption>
<img class="media" src="images/monasteryNaive.jpg"
alt="monasteryNaive.jpg" loading="lazy" width="50%"/>
</div>
<figcaption>Best shift: (-2, 344), (1, -335)<br>5.107604s</figcaption>
</figure>

<figure style="flex:1; text-align:center;">
<div class="figure-wrap">
<figcaption>tobolsk.jpg</figcaption>
<img class="media" src="images/tobolskNaive.jpg"
alt="tobolskNaive.jpg" loading="lazy" width="50%"/>
</div>
<figcaption>Best shift: (-3, 338), (1, -337)<br>5.857907s</figcaption>
</figure>

</div>

<!-- Section 4 -->
<h2>Image Pyramid</h2>
<p>
Unfortunately, because each crop has a height of <i>(7W / 8)</i> &times; <i>(5H / 24)</i>, the total number of NCC computations for each alignment is <i>((W - 7W / 8) + 1)</i> &times; <i>((H/3 - 5H / 24) + 1)</i> = <i>(W / 8 + 1)</i> &times; <i>(H / 8 + 1)</i> = <i>O(HW)</i>. Since each NCC computation requires <i>O(HW)</i> operations, aligning an image of dimensions <i>W</i> &times; <i>H</i> takes <i>O((HW)<sup>2</sup>)</i> time using the naive search above. Because the .tif files are about 9 times bigger than the .jpg files in both dimensions, performing the same search on these files will take more than 6500x more time to compute (hours instead of seconds). Even if the width is fixed, it would still require more than 9<sup>3</sup> &approx; 720x more time on .tif files. A more efficient method is required.<br>
<br>
Instead of searching over the entire image, we can scale down the image and find the best shiftat a much smaller size. Once the most accurate displacement (<i>x</i><sub>lowest</sub>, <i>y</i><sub>lowest</sub>) is calculated for the lowest sized image, we can perform another search at the image 2x the size. Only this time, we start at (<i>2x</i><sub>lowest</sub>, <i>2y</i><sub>lowest</sub>), and only search over a window of [-2, 2] for pixel corrections. Once the best displacement at the layer above the lowest scale is computed, we can multiply the result again by 2 and pass it to the image in the next layer above. The limited window is used because each downscaled coordinate could have only come from a total of 4 different coordaintes, so the best coordinate on the higher scale is only limited to [-1, 1] of the interpolated coordinate. An additional pixel in the search range is used to ensure further reduce the effect of noise on the best placement at the lowest scale. To further optimze this approrach without storing all downscale images at once, we can modify the best displacement function to have a recursive call.<br>
<br>
Instead of directly computing the best displacement on the full image, we only calculate if the given with is below a certain threshold. For images above this threshold, we can first downscale the image by 2x, pass it back to the function, and the returned shifts scaled up by 2x to return the best shifts on the input image. This means that the best shifts in the base case (<i>x</i><sub>lowest</sub>, <i>y</i><sub>lowest</sub>) will be scaled up and used in the previous recursive call, which is the scaled image 1 layer above. This will continue until we return to the top level call, and at that point, the returned shifts will be within 1 or 2 pixels of the best overall displacement. The last thing to keep in mind is to downscale the cropping box as well, which is simple to do since it is computed on the full image and one can simply divide its coordinates by 2 for each recurive call. In practice, setting W<sub>min</sub> = 72 gives the best tradeoff between the search size and the number of rescales. With these optimzations in place, the computing time is now much faster:
</p>
<div align="center">
<img src="image4.jpg" alt="Description of image 4" width="400">
</div>

<!-- Section 5 -->
<h2>Cropping with Sobel</h2>
<p>
This is some body text for subheading 5. Summarize outcomes or provide references.
</p>
<div align="center">
<img src="image5.jpg" alt="Description of image 5" width="400">
</div>

</body>
</html>
